<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sankey Diagram Generator - Web App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 10px;
        }
        
        .container {
            display: grid;
            grid-template-columns: minmax(320px, 350px) 1fr;
            gap: 10px;
            height: 98vh;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .left-panel {
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }
        
        h2 {
            font-size: 14px;
            margin: 15px 0 8px 0;
            color: #555;
            font-weight: 600;
        }
        
        .section {
            margin-bottom: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        
        .param-row label {
            flex: 0 0 100px;
            font-size: 13px;
            color: #666;
        }
        
        input[type="number"], input[type="text"] {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button.secondary {
            background: #6c757d;
        }
        
        button.secondary:hover {
            background: #545b62;
        }
        
        button.success {
            background: #28a745;
        }
        
        button.success:hover {
            background: #218838;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .button-grid button {
            width: 100%;
        }
        
        canvas {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }
        
        .status {
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
            color: #495057;
        }
        
        .info-text {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
        }
        
        .value-display {
            font-size: 12px;
            color: #007bff;
            padding: 6px;
            background: #e7f3ff;
            border-radius: 4px;
            margin: 8px 0;
        }
        
        .scale-display {
            font-size: 12px;
            color: #28a745;
            padding: 6px;
            background: #d4edda;
            border-radius: 4px;
            margin: 8px 0;
        }
        
        select {
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
            margin: 8px 0;
        }
        
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            color: #666;
            cursor: pointer;
        }
        
        input[type="radio"] {
            cursor: pointer;
        }
        
        .column-control {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            transform: translateX(-50%);
            overflow: visible;
            z-index: 10;
        }
        .column-control input.socket-input {
            min-width: 42px;
            width: 42px;
            padding: 4px 6px;
            font-size: 13px;
            text-align: center;
            box-sizing: border-box;
        }
        .column-control .align-btn {
            padding: 4px 8px;
            font-size: 11px;
            margin-top: 4px;
        }
        #columnInputsOverlay {
            overflow: visible;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Controls -->
        <div class="panel left-panel">
            <h1>ðŸŽ¨ Sankey Controls</h1>
            
            <div class="section">
                <h2>Columns</h2>
                <div class="param-row">
                    <label>Number of columns:</label>
                    <input type="number" id="numColumns" value="6" min="2" max="20" title="Press Enter to apply">
                </div>
                <div class="info-text">Press Enter to apply</div>
            </div>
            
            <div class="section">
                <h2>Thread Randomization</h2>
                <div class="param-row">
                    <label>Thread ID:</label>
                    <input type="number" id="selectedThread" value="0" min="0">
                    <label style="flex: 0 0 50px;">Seed:</label>
                    <input type="number" id="seedValue" value="42" min="1">
                </div>
                <div class="button-grid">
                    <button onclick="setSeed()">Set Seed</button>
                    <button onclick="randomizeSeed()" class="secondary">Randomize</button>
                </div>
                <div class="info-text">Thread 0 = Col0â†’Col1, Thread 1 = Col1â†’Col2, etc.</div>
            </div>
            
            <div class="section">
                <h2>Physical Dimensions (meters)</h2>
                <div class="param-row">
                    <label>Width (X):</label>
                    <input type="number" id="scaleX" value="1.0" step="0.1" min="0.1">
                    <span style="flex: 0 0 20px;">m</span>
                </div>
                <div class="param-row">
                    <label>Height (Y):</label>
                    <input type="number" id="scaleY" value="1.0" step="0.1" min="0.1">
                    <span style="flex: 0 0 20px;">m</span>
                </div>
                <div class="scale-display" id="scaleDisplay">1.0m Ã— 1.0m (1000mm Ã— 1000mm)</div>
            </div>
            
            <button onclick="updatePreview()" class="success" style="width: 100%; font-size: 15px; padding: 12px; margin: 15px 0;">
                â†» UPDATE PREVIEW
            </button>
            
            <div class="section">
                <h2>Actions</h2>
                <button onclick="autoGenerate()" style="width: 100%; margin-bottom: 8px;">Auto-Generate Random</button>
            </div>
            
            <div class="section">
                <h2>SVG Export Mode</h2>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="svgMode" value="full" checked> Full Curves
                    </label>
                    <label>
                        <input type="radio" name="svgMode" value="segmented"> Segmented
                    </label>
                </div>
            </div>
            
            <div class="section">
                <h2>Import / Export</h2>
                <input type="file" id="csvImport" accept=".csv" style="display: none;" onchange="importCSV(event)">
                <div class="button-grid">
                    <button onclick="document.getElementById('csvImport').click()">Import CSV</button>
                    <button onclick="exportCSV()">Export CSV</button>
                </div>
                <button onclick="saveSVG()" style="width: 100%; margin-top: 8px;">Save SVG</button>
            </div>
            
            <div class="status" id="status">Ready. Click UPDATE PREVIEW to start.</div>
            <div class="status" style="background: #fff3cd; color: #856404; margin-top: 5px;" id="connectionCount">
                Connections: 0
            </div>
        </div>
        
        <!-- Right Panel: Preview -->
        <div class="panel right-panel">
            <div class="preview-header" style="display: flex; align-items: center; gap: 16px; margin-bottom: 8px; flex-shrink: 0;">
                <h1 style="margin-bottom: 0;">Real-time Preview</h1>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; color: #666;">
                    Zoom:
                    <input type="range" id="zoomSlider" min="25" max="200" value="100" style="width: 100px;">
                    <span id="zoomValue">100%</span>
                </label>
            </div>
            <div class="preview-viewport" style="display: flex; flex: 1; min-height: 0; gap: 8px;">
                <div class="pan-y-slider-wrap" style="display: flex; flex-direction: column; align-items: center; flex-shrink: 0;">
                    <span style="font-size: 10px; color: #666;">Pan Y</span>
                    <div style="height: 120px; display: flex; align-items: center;">
                        <input type="range" id="panYSlider" min="-200" max="200" value="0" style="width: 120px; transform: rotate(-90deg); margin: 0;">
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0;">
                    <div class="canvas-wrap" id="canvasWrap" style="position:relative; flex:1; min-height:0; overflow:auto;">
                        <div id="zoomContainer" style="position: relative; transform-origin: 0 0;">
                            <div id="scaleDiv" style="position: absolute; transform-origin: 0 0;">
                                <canvas id="preview"></canvas>
                            </div>
                            <div id="columnInputsOverlay" style="position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none;"></div>
                        </div>
                    </div>
                    <div class="pan-x-slider-wrap" style="display: flex; align-items: center; gap: 8px; flex-shrink: 0; padding: 4px 0;">
                        <span style="font-size: 10px; color: #666;">Pan X</span>
                        <input type="range" id="panXSlider" min="-200" max="200" value="0" style="flex: 1;">
                    </div>
                </div>
            </div>
            <div class="info-text" style="margin-top: 10px; text-align: center; flex-shrink: 0;">
                Preview shows diagram structure. Drag sockets to adjust; drag column label to move column. SVG export uses exact physical dimensions.
            </div>
        </div>
    </div>

    <script>
        // State
        let connections = [];
        let socketsPerColumn = {};
        let threadSeeds = {};
        let numColumns = 6;
        let columnX = {};           // col -> x_mm (optional; column drag)
        let socketPositions = {};   // node -> [x_mm, y_mm] (optional override; socket drag or import)
        let dragNode = null;
        let dragColumn = null;
        let columnCenterPx = {};    // col -> x pixel (for overlay positioning)
        let previewZoom = 1;        // 0.25 to 2
        let baseCanvasW = 400, baseCanvasH = 300;
        let panX = 0, panY = 0;     // pan in pixels, range e.g. -200 to 200
        const PAN_MARGIN = 200;
        const PAN_RANGE = 200;
        
        // Initialize
        function init() {
            numColumns = parseInt(document.getElementById('numColumns').value);
            for (let i = 0; i < numColumns; i++) {
                socketsPerColumn[i] = 10;
                if (i < numColumns - 1) {
                    threadSeeds[i] = 42;
                }
            }
            updateScaleDisplay();
            updatePreview();
        }
        
        function updateScaleDisplay() {
            const x = parseFloat(document.getElementById('scaleX').value);
            const y = parseFloat(document.getElementById('scaleY').value);
            const xmm = (x * 1000).toFixed(0);
            const ymm = (y * 1000).toFixed(0);
            document.getElementById('scaleDisplay').textContent = 
                `${x}m Ã— ${y}m (${xmm}mm Ã— ${ymm}mm)`;
        }
        
        // Thread seed control
        function setSeed() {
            const threadId = parseInt(document.getElementById('selectedThread').value);
            const seed = parseInt(document.getElementById('seedValue').value);
            
            if (threadId >= 0 && threadId < numColumns - 1 && seed > 0) {
                threadSeeds[threadId] = seed;
                updatePreview();
                setStatus(`Thread ${threadId} seed set to ${seed}`);
            }
        }
        
        function randomizeSeed() {
            const threadId = parseInt(document.getElementById('selectedThread').value);
            const newSeed = Math.floor(Math.random() * 9999) + 1;
            
            threadSeeds[threadId] = newSeed;
            document.getElementById('seedValue').value = newSeed;
            updatePreview();
            setStatus(`Thread ${threadId} randomized with seed ${newSeed}`);
        }
        
        // Auto-generate
        function autoGenerate() {
            // Randomize all thread seeds
            for (let i = 0; i < numColumns - 1; i++) {
                threadSeeds[i] = Math.floor(Math.random() * 9999) + 1;
            }
            
            // Update displayed seed
            const currentThread = parseInt(document.getElementById('selectedThread').value);
            document.getElementById('seedValue').value = threadSeeds[currentThread] || 42;
            
            updatePreview();
            setStatus('Auto-generated with random seeds');
        }
        
        // Generate connections from parameters.
        // Only column 0 defines the total number of lines; each line is one path from Col0 to last column.
        function generateConnections() {
            connections = [];
            const nLines = socketsPerColumn[0] || 10;
            
            for (let lineId = 0; lineId < nLines; lineId++) {
                const path = [];
                let current = `Col0_Socket${lineId}`;
                
                for (let threadId = 0; threadId < numColumns - 1; threadId++) {
                    const colTo = threadId + 1;
                    const socketsTo = socketsPerColumn[colTo] || 10;
                    const seed = threadSeeds[threadId] || 42;
                    seededRandom(seed + lineId * 1000);
                    
                    const targetIdx = Math.floor(seededRandom() * socketsTo);
                    const target = `Col${colTo}_Socket${targetIdx}`;
                    const value = Math.floor(seededRandom() * 9) + 1;
                    
                    path.push({ source: current, target, value });
                    current = target;
                }
                
                for (const edge of path) {
                    connections.push(edge);
                }
            }
            
            document.getElementById('connectionCount').textContent = `Connections: ${connections.length} (${nLines} lines from Col0)`;
        }
        
        // Seeded random number generator
        let seed = 42;
        function seededRandom(newSeed) {
            if (newSeed !== undefined) {
                seed = newSeed;
            }
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        // Update preview
        function updatePreview() {
            // Update number of columns
            const newNumCols = parseInt(document.getElementById('numColumns').value);
            if (newNumCols !== numColumns) {
                numColumns = newNumCols;
                
                // Initialize new columns/threads
                for (let i = 0; i < numColumns; i++) {
                    if (socketsPerColumn[i] === undefined) {
                        socketsPerColumn[i] = 10;
                    }
                    if (i < numColumns - 1 && threadSeeds[i] === undefined) {
                        threadSeeds[i] = 42;
                    }
                }
                
                // Update UI limits
                document.getElementById('selectedThread').max = Math.max(0, numColumns - 2);
            }
            
            updateScaleDisplay();
            generateConnections();
            drawCanvas();
            setStatus('Preview updated');
        }
        
        // Draw canvas
        function drawCanvas() {
            const canvas = document.getElementById('preview');
            const ctx = canvas.getContext('2d');
            const wrap = document.getElementById('canvasWrap');
            const zoomContainer = document.getElementById('zoomContainer');
            const scaleDiv = document.getElementById('scaleDiv');
            
            previewZoom = (document.getElementById('zoomSlider')?.value ?? 100) / 100;
            document.getElementById('zoomValue').textContent = Math.round(previewZoom * 100) + '%';
            
            if (wrap && wrap.clientWidth && wrap.clientHeight && previewZoom === 1) {
                baseCanvasW = wrap.clientWidth;
                baseCanvasH = wrap.clientHeight;
            }
            canvas.width = baseCanvasW;
            canvas.height = baseCanvasH;
            const zoomW = baseCanvasW * previewZoom;
            const zoomH = baseCanvasH * previewZoom;
            const centerOffsetX = (zoomW - baseCanvasW) / 2;
            const centerOffsetY = (zoomH - baseCanvasH) / 2;
            scaleDiv.style.width = baseCanvasW + 'px';
            scaleDiv.style.height = baseCanvasH + 'px';
            scaleDiv.style.transform = `scale(${previewZoom})`;
            scaleDiv.style.transformOrigin = '0 0';
            scaleDiv.style.position = 'absolute';
            scaleDiv.style.left = (PAN_MARGIN + centerOffsetX + panX) + 'px';
            scaleDiv.style.top = (PAN_MARGIN + centerOffsetY + panY) + 'px';
            zoomContainer.style.width = (zoomW + 2 * PAN_MARGIN) + 'px';
            zoomContainer.style.height = (zoomH + 2 * PAN_MARGIN) + 'px';
            zoomContainer.style.position = 'relative';
            requestAnimationFrame(function() {
                if (wrap && wrap.clientWidth && wrap.clientHeight) {
                    wrap.scrollLeft = (zoomContainer.scrollWidth - wrap.clientWidth) / 2;
                    wrap.scrollTop = (zoomContainer.scrollHeight - wrap.clientHeight) / 2;
                }
            });
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (connections.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Click UPDATE PREVIEW to generate diagram', canvas.width / 2, canvas.height / 2);
                window._lastDrawState = null;
                document.getElementById('columnInputsOverlay').innerHTML = '';
                return;
            }
            
            // Get scale aspect ratio
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const aspectRatio = scaleX / scaleY;
            
            // Calculate drawable area respecting aspect ratio
            const canvasAspect = canvas.width / canvas.height;
            let drawW, drawH, offsetX, offsetY;
            
            if (aspectRatio > canvasAspect) {
                // Width-constrained
                drawW = canvas.width;
                drawH = canvas.width / aspectRatio;
                offsetX = 0;
                offsetY = (canvas.height - drawH) / 2;
            } else {
                // Height-constrained
                drawH = canvas.height;
                drawW = canvas.height * aspectRatio;
                offsetX = (canvas.width - drawW) / 2;
                offsetY = 0;
            }
            
            // Draw aspect ratio border
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(offsetX, offsetY, drawW, drawH);
            ctx.setLineDash([]);
            
            const [positionsMm, widthMm, heightMm] = calculatePositionsMm();
            const toPx = (xMm, yMm) => [
                offsetX + (xMm / widthMm) * drawW,
                offsetY + (yMm / heightMm) * drawH
            ];
            const positions = {};
            columnCenterPx = {};
            for (const [node, xy] of Object.entries(positionsMm)) {
                positions[node] = toPx(xy[0], xy[1]);
                const col = parseInt(node.split('_')[0].replace('Col', ''));
                if (columnCenterPx[col] === undefined) columnCenterPx[col] = { sum: positions[node][0], n: 1 };
                else { columnCenterPx[col].sum += positions[node][0]; columnCenterPx[col].n++; }
            }
            Object.keys(columnCenterPx).forEach(col => {
                const o = columnCenterPx[col];
                columnCenterPx[col] = o.sum / o.n;
            });
            
            // Draw connections
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            
            for (const conn of connections) {
                const p1 = positions[conn.source];
                const p2 = positions[conn.target];
                
                if (p1 && p2) {
                    drawBezierCurve(ctx, p1[0], p1[1], p2[0], p2[1]);
                }
            }
            
            // Draw nodes
            ctx.globalAlpha = 1.0;
            for (const [node, [x, y]] of Object.entries(positions)) {
                const colNum = parseInt(node.split('_')[0].replace('Col', ''));
                
                if (colNum === 0) {
                    ctx.fillStyle = '#2ecc71'; // Green
                } else if (colNum === numColumns - 1) {
                    ctx.fillStyle = '#e74c3c'; // Red
                } else {
                    ctx.fillStyle = '#f39c12'; // Orange
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw column labels: blue box + text (always visible, draggable)
            const labelY = offsetY + 20;
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            for (const col of Object.keys(columnCenterPx).map(Number).sort((a,b)=>a-b)) {
                const text = `Col ${col}`;
                const m = ctx.measureText(text);
                const pad = 6;
                const boxW = m.width + pad * 2;
                const boxH = 18;
                const x = columnCenterPx[col];
                ctx.fillStyle = 'rgba(30, 100, 200, 0.95)';
                ctx.strokeStyle = '#1a5fb4';
                ctx.lineWidth = 1.5;
                roundRect(ctx, x - boxW/2, labelY - boxH/2, boxW, boxH, 4);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#fff';
                ctx.fillText(text, x, labelY);
            }
            ctx.textBaseline = 'alphabetic';
            
            // Display aspect ratio and scale info
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Scale: ${scaleX}m Ã— ${scaleY}m (Aspect: ${aspectRatio.toFixed(2)}:1)`, 
                        canvas.width / 2, canvas.height - 10);
            
            window._lastDrawState = { offsetX, offsetY, drawW, drawH, widthMm, heightMm, positions, positionsMm, columnCenterPx: Object.assign({}, columnCenterPx), labelY: offsetY + 20 };
            updateColumnOverlay();
        }
        
        function updateColumnOverlay() {
            const overlay = document.getElementById('columnInputsOverlay');
            if (!overlay) return;
            const cols = Object.keys(columnCenterPx).map(Number).sort((a, b) => a - b);
            const scaleDivLeft = PAN_MARGIN + (baseCanvasW * previewZoom - baseCanvasW) / 2 + panX;
            const scaleDivTop = PAN_MARGIN + (baseCanvasH * previewZoom - baseCanvasH) / 2 + panY;
            overlay.innerHTML = '';
            cols.forEach(col => {
                const div = document.createElement('div');
                div.className = 'column-control';
                div.style.left = (scaleDivLeft + (columnCenterPx[col] || 0) * previewZoom) + 'px';
                div.style.top = (scaleDivTop + 8) + 'px';
                const inp = document.createElement('input');
                inp.type = 'number';
                inp.className = 'socket-input';
                inp.min = 1;
                inp.value = socketsPerColumn[col] ?? 10;
                inp.dataset.col = col;
                inp.addEventListener('change', function() {
                    const c = parseInt(this.dataset.col);
                    const v = parseInt(this.value) || 1;
                    socketsPerColumn[c] = v;
                    updatePreview();
                });
                const btn = document.createElement('button');
                btn.className = 'align-btn secondary';
                btn.textContent = 'Align';
                btn.dataset.col = col;
                btn.addEventListener('click', function() { alignColumn(parseInt(this.dataset.col)); });
                div.appendChild(inp);
                div.appendChild(btn);
                overlay.appendChild(div);
            });
        }
        
        function alignColumn(col) {
            const columns = getColumnsFromConnections();
            const nodes = Array.from(columns[col] || []);
            nodes.forEach(n => { delete socketPositions[n]; });
            drawCanvas();
            setStatus(`Column ${col} aligned`);
        }
        
        function calculateNodePositions(width, height, offsetX, offsetY) {
            const columns = {};
            
            for (const conn of connections) {
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                
                if (!columns[srcCol]) columns[srcCol] = new Set();
                if (!columns[tgtCol]) columns[tgtCol] = new Set();
                
                columns[srcCol].add(conn.source);
                columns[tgtCol].add(conn.target);
            }
            
            const positions = {};
            const marginX = 60;
            const marginY = 40;
            const usableWidth = width - 2 * marginX;
            const usableHeight = height - 2 * marginY;
            
            const sortedCols = Object.keys(columns).sort((a, b) => a - b);
            const xStep = sortedCols.length > 1 ? usableWidth / (sortedCols.length - 1) : 0;
            
            sortedCols.forEach((col, colIdx) => {
                const nodes = Array.from(columns[col]).sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
                
                const x = offsetX + marginX + (colIdx * xStep);
                const yStep = nodes.length > 1 ? usableHeight / (nodes.length - 1) : 0;
                
                nodes.forEach((node, nodeIdx) => {
                    const y = offsetY + marginY + (nodeIdx * yStep);
                    positions[node] = [x, y];
                });
            });
            
            return positions;
        }
        
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        
        function drawBezierCurve(ctx, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const cx1 = x1 + dx * 0.5;
            const cy1 = y1;
            const cx2 = x1 + dx * 0.5;
            const cy2 = y2;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
            ctx.stroke();
        }
        
        // CSV Export with full parameters and socket positions (column#, socket#, X, Y)
        function exportCSV() {
            if (connections.length === 0) {
                alert('No connections to export');
                return;
            }
            const [positionsMm] = calculatePositionsMm();
            
            let csv = '#SANKEY_PARAMETERS\n';
            csv += `num_columns,${numColumns}\n`;
            csv += `scale_x_meters,${document.getElementById('scaleX').value}\n`;
            csv += `scale_y_meters,${document.getElementById('scaleY').value}\n`;
            
            csv += '#SOCKET_CONFIGURATION\n';
            for (let i = 0; i < numColumns; i++) {
                csv += `col_${i}_sockets,${socketsPerColumn[i] || 10}\n`;
            }
            
            csv += '#THREAD_SEEDS\n';
            for (let i = 0; i < numColumns - 1; i++) {
                csv += `thread_${i}_seed,${threadSeeds[i] || 42}\n`;
            }
            
            csv += '#SOCKET_POSITIONS\n';
            csv += 'column,socket,X,Y\n';
            const socketRows = Object.entries(positionsMm).map(([node, xy]) => {
                const col = parseInt(node.split('_')[0].replace('Col', ''));
                const socket = parseInt(node.split('_Socket')[1]);
                return { col, socket, x: xy[0], y: xy[1] };
            });
            socketRows.sort((a, b) => a.col !== b.col ? a.col - b.col : a.socket - b.socket);
            for (const r of socketRows) {
                csv += `${r.col},${r.socket},${r.x},${r.y}\n`;
            }
            
            csv += '#CONNECTIONS\n';
            csv += 'source,target,value\n';
            for (const conn of connections) {
                csv += `${conn.source},${conn.target},${conn.value}\n`;
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sankey_design.csv';
            a.click();
            
            setStatus('Exported complete design to CSV');
        }
        
        // CSV Import with full parameters
        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split('\n');
                
                let mode = 'connections';
                connections = [];
                const tempSockets = {};
                const tempSeeds = {};
                const tempSocketPositions = {};
                let tempNumCols = null;
                let tempScaleX = null;
                let tempScaleY = null;
                
                for (const line of lines) {
                    const parts = line.trim().split(',');
                    if (parts.length === 0 || !parts[0]) continue;
                    
                    if (parts[0].startsWith('#')) {
                        if (parts[0] === '#SANKEY_PARAMETERS') mode = 'parameters';
                        else if (parts[0] === '#SOCKET_CONFIGURATION') mode = 'sockets';
                        else if (parts[0] === '#THREAD_SEEDS') mode = 'seeds';
                        else if (parts[0] === '#SOCKET_POSITIONS') mode = 'socket_positions';
                        else if (parts[0] === '#CONNECTIONS') mode = 'connections';
                        continue;
                    }
                    
                    if (mode === 'parameters') {
                        if (parts[0] === 'num_columns') tempNumCols = parseInt(parts[1]);
                        else if (parts[0] === 'scale_x_meters') tempScaleX = parseFloat(parts[1]);
                        else if (parts[0] === 'scale_y_meters') tempScaleY = parseFloat(parts[1]);
                    } else if (mode === 'sockets') {
                        if (parts[0].startsWith('col_') && parts[0].endsWith('_sockets')) {
                            const colNum = parseInt(parts[0].split('_')[1]);
                            tempSockets[colNum] = parseInt(parts[1]);
                        }
                    } else if (mode === 'seeds') {
                        if (parts[0].startsWith('thread_') && parts[0].endsWith('_seed')) {
                            const threadId = parseInt(parts[0].split('_')[1]);
                            tempSeeds[threadId] = parseInt(parts[1]);
                        }
                    } else if (mode === 'socket_positions') {
                        if (parts[0] === 'column') continue; // Skip header
                        if (parts.length >= 4) {
                            const col = parseInt(parts[0]);
                            const socket = parseInt(parts[1]);
                            const x = parseFloat(parts[2]);
                            const y = parseFloat(parts[3]);
                            const node = `Col${col}_Socket${socket}`;
                            tempSocketPositions[node] = [x, y];
                        }
                    } else if (mode === 'connections') {
                        if (parts[0] === 'source') continue; // Skip header
                        if (parts.length >= 3) {
                            connections.push({
                                source: parts[0].trim(),
                                target: parts[1].trim(),
                                value: parseFloat(parts[2])
                            });
                        }
                    }
                }
                
                // Apply imported parameters
                if (tempNumCols !== null) {
                    numColumns = tempNumCols;
                    document.getElementById('numColumns').value = tempNumCols;
                }
                
                if (tempScaleX !== null) {
                    document.getElementById('scaleX').value = tempScaleX;
                }
                
                if (tempScaleY !== null) {
                    document.getElementById('scaleY').value = tempScaleY;
                }
                
                if (Object.keys(tempSockets).length > 0) {
                    socketsPerColumn = tempSockets;
                }
                
                if (Object.keys(tempSeeds).length > 0) {
                    threadSeeds = tempSeeds;
                    const currentThread = parseInt(document.getElementById('selectedThread').value);
                    if (threadSeeds[currentThread] !== undefined) {
                        document.getElementById('seedValue').value = threadSeeds[currentThread];
                    }
                }
                
                if (Object.keys(tempSocketPositions).length > 0) {
                    socketPositions = tempSocketPositions;
                }
                
                updateScaleDisplay();
                drawCanvas();
                
                document.getElementById('connectionCount').textContent = `Connections: ${connections.length}`;
                setStatus(`Imported complete design: ${connections.length} connections`);
                alert(`Imported complete design:\n- ${connections.length} connections\n- ${numColumns} columns\n- All parameters restored`);
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // SVG Export
        function saveSVG() {
            if (connections.length === 0) {
                alert('Generate connections first');
                return;
            }
            
            const mode = document.querySelector('input[name="svgMode"]:checked').value;
            
            if (mode === 'full') {
                generateFullCurveSVG();
            } else {
                generateSegmentedCurveSVG();
            }
        }
        
        function generateFullCurveSVG() {
            // Build graph
            const graph = {};
            const nodeType = {};
            
            for (const conn of connections) {
                if (!graph[conn.source]) graph[conn.source] = [];
                graph[conn.source].push([conn.target, conn.value]);
                
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                
                nodeType[conn.source] = srcCol === 0 ? 'input' : (srcCol === numColumns - 1 ? 'output' : 'joint');
                nodeType[conn.target] = tgtCol === 0 ? 'input' : (tgtCol === numColumns - 1 ? 'output' : 'joint');
            }
            
            // Get all Column 0 sockets (inputs) - sorted for consistency
            const inputNodes = Object.keys(nodeType)
                .filter(n => nodeType[n] === 'input')
                .sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
            
            // Trace exactly ONE path per input socket
            const allPaths = [];
            
            function traceSinglePath(current, path, visited) {
                // Trace one path from input to output - take first available connection
                if (nodeType[current] === 'output') {
                    return true; // Found an output, path is complete
                }
                
                if (visited.has(current)) {
                    return false; // Circular reference, abort
                }
                
                visited.add(current);
                
                // Get connections from current node
                const connections = graph[current] || [];
                if (connections.length === 0) {
                    return false; // Dead end
                }
                
                // Take the FIRST connection (deterministic - ensures one path per input)
                for (const [next, value] of connections) {
                    path.push([current, next, value]);
                    if (traceSinglePath(next, path, visited)) {
                        return true; // Successfully reached output
                    }
                    path.pop(); // Backtrack if this path didn't work
                }
                
                return false; // No valid path found
            }
            
            // Trace exactly one path for each input socket
            for (const inputNode of inputNodes) {
                const path = [];
                const visited = new Set();
                if (traceSinglePath(inputNode, path, visited)) {
                    allPaths.push(path);
                }
                // If no valid path exists for this input, it's simply skipped
            }
            
            // Calculate positions
            const [positions, widthMm, heightMm] = calculateSVGNodePositions();
            
            // Generate SVG
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<!-- Physical dimensions: ${document.getElementById('scaleX').value}m Ã— ${document.getElementById('scaleY').value}m -->\n`;
            svg += `<!-- Units: millimeters (1 SVG unit = 1mm) -->\n`;
            svg += `<!-- Full Curves Mode: ${allPaths.length} curves (one per Column 0 socket) -->\n`;
            svg += `<svg width="${widthMm}mm" height="${heightMm}mm" viewBox="0 0 ${widthMm} ${heightMm}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<g id="sankey_threads">\n`;
            
            let threadCount = 0;
            for (const path of allPaths) {
                if (path.length === 0) continue;
                
                const nodes = [path[0][0]];
                for (const [src, tgt, val] of path) {
                    nodes.push(tgt);
                }
                
                const points = nodes.map(n => positions[n]).filter(p => p !== undefined);
                if (points.length < 2) continue;
                
                const pathD = createSmoothCurvePath(points);
                const color = getThreadColor(threadCount, allPaths.length);
                
                svg += `  <path id="thread_${threadCount}" class="full_thread from_${nodes[0]}" d="${pathD}" stroke="${color}" stroke-width="2" fill="none" opacity="0.7"/>\n`;
                threadCount++;
            }
            
            svg += `</g>\n</svg>`;
            
            downloadFile('sankey_full.svg', svg, 'image/svg+xml');
            setStatus(`Saved ${threadCount} full curves as SVG (one per Column 0 socket)`);
        }
        
        function generateSegmentedCurveSVG() {
            const [positions, widthMm, heightMm] = calculateSVGNodePositions();
            const nextNode = {};
            for (const conn of connections) {
                nextNode[conn.source] = conn.target;
            }
            const nLines = socketsPerColumn[0] || 10;
            const allPaths = [];
            for (let i = 0; i < nLines; i++) {
                const path = [];
                let cur = `Col0_Socket${i}`;
                while (cur && positions[cur]) {
                    path.push(cur);
                    cur = nextNode[cur];
                }
                if (path.length >= 2) allPaths.push(path);
            }
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<!-- Physical dimensions: ${document.getElementById('scaleX').value}m Ã— ${document.getElementById('scaleY').value}m -->\n`;
            svg += `<!-- Units: millimeters (1 SVG unit = 1mm) -->\n`;
            svg += `<!-- Segmented: full curves split at sockets -->\n`;
            svg += `<svg width="${widthMm}mm" height="${heightMm}mm" viewBox="0 0 ${widthMm} ${heightMm}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<g id="sankey_segments">\n`;
            let segmentCount = 0;
            for (let pi = 0; pi < allPaths.length; pi++) {
                const path = allPaths[pi];
                const points = path.map(n => positions[n]).filter(p => p);
                for (let i = 0; i < points.length - 1; i++) {
                    const pathD = createSmoothCurvePath([points[i], points[i + 1]]);
                    const color = getThreadColor(pi, allPaths.length);
                    svg += `  <path id="segment_${segmentCount}" d="${pathD}" stroke="${color}" stroke-width="2" fill="none" opacity="0.7"/>\n`;
                    segmentCount++;
                }
            }
            svg += `</g>\n</svg>`;
            downloadFile('sankey_segmented.svg', svg, 'image/svg+xml');
            setStatus(`Saved ${segmentCount} segments (full curves split at sockets)`);
        }
        
        function getColumnsFromConnections() {
            const columns = {};
            for (const conn of connections) {
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                if (!columns[srcCol]) columns[srcCol] = new Set();
                if (!columns[tgtCol]) columns[tgtCol] = new Set();
                columns[srcCol].add(conn.source);
                columns[tgtCol].add(conn.target);
            }
            return columns;
        }
        
        function calculatePositionsMm() {
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const widthMm = scaleX * 1000;
            const heightMm = scaleY * 1000;
            const marginX = widthMm * 0.1;
            const marginY = heightMm * 0.1;
            const columns = getColumnsFromConnections();
            const sortedCols = Object.keys(columns).sort((a, b) => a - b);
            const xStep = sortedCols.length > 1 ? (widthMm - 2 * marginX) / (sortedCols.length - 1) : 0;
            const positions = {};
            sortedCols.forEach((col, colIdx) => {
                const nodes = Array.from(columns[col]).sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
                const baseX = columnX[col] != null ? columnX[col] : (marginX + colIdx * xStep);
                const yStep = nodes.length > 1 ? (heightMm - 2 * marginY) / (nodes.length - 1) : 0;
                nodes.forEach((node, nodeIdx) => {
                    const y = marginY + (nodeIdx * yStep);
                    if (socketPositions[node]) {
                        positions[node] = socketPositions[node].slice();
                    } else {
                        positions[node] = [baseX, y];
                    }
                });
            });
            return [positions, widthMm, heightMm];
        }
        
        function calculateSVGNodePositions() {
            return calculatePositionsMm();
        }
        
        function createSmoothCurvePath(points) {
            if (points.length < 2) return '';
            
            let path = `M ${points[0][0]},${points[0][1]}`;
            
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                const dx = x2 - x1;
                const cx1 = x1 + dx * 0.5;
                const cy1 = y1;
                const cx2 = x1 + dx * 0.5;
                const cy2 = y2;
                
                path += ` C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
            }
            
            return path;
        }
        
        function getThreadColor(index, total) {
            const hue = (index * 360 / total) % 360;
            return `hsl(${hue}, 70%, 50%)`;
        }
        
        function downloadFile(filename, content, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
        }
        
        function setStatus(msg) {
            document.getElementById('status').textContent = msg;
        }
        
        // Event listeners
        document.getElementById('numColumns').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                updatePreview();
            }
        });
        document.getElementById('scaleX').addEventListener('input', function() {
            updateScaleDisplay();
            if (connections.length > 0) drawCanvas();
        });
        document.getElementById('scaleY').addEventListener('input', function() {
            updateScaleDisplay();
            if (connections.length > 0) drawCanvas();
        });
        document.getElementById('selectedThread').addEventListener('input', function() {
            const threadId = parseInt(this.value);
            if (threadSeeds[threadId] !== undefined) {
                document.getElementById('seedValue').value = threadSeeds[threadId];
            }
        });
        document.getElementById('zoomSlider').addEventListener('input', function() {
            previewZoom = parseInt(this.value) / 100;
            document.getElementById('zoomValue').textContent = this.value + '%';
            drawCanvas();
        });
        document.getElementById('panXSlider').addEventListener('input', function() {
            panX = parseInt(this.value);
            drawCanvas();
        });
        document.getElementById('panYSlider').addEventListener('input', function() {
            panY = parseInt(this.value);
            drawCanvas();
        });
        
        let lastMousePx = [0, 0];
        
        function getCanvasMouse(e) {
            const canvas = document.getElementById('preview');
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return [(e.clientX - r.left) * scaleX, (e.clientY - r.top) * scaleY];
        }
        
        function hitTestColumnLabel(px, py) {
            const s = window._lastDrawState;
            if (!s || !s.columnCenterPx) return null;
            const cols = Object.keys(s.columnCenterPx).map(Number);
            for (const col of cols) {
                const lx = s.columnCenterPx[col];
                const ly = s.labelY;
                if (Math.abs(px - lx) < 45 && Math.abs(py - ly) < 14) return col;
            }
            return null;
        }
        
        function hitTestSocket(px, py) {
            const s = window._lastDrawState;
            if (!s || !s.positions) return null;
            const r = 10;
            let best = null, bestD = r * r;
            for (const [node, [x, y]] of Object.entries(s.positions)) {
                const d = (px - x) ** 2 + (py - y) ** 2;
                if (d < bestD) { bestD = d; best = node; }
            }
            return best;
        }
        
        function canvasMouseDown(e) {
            const [px, py] = getCanvasMouse(e);
            const col = hitTestColumnLabel(px, py);
            if (col != null) {
                dragColumn = col;
                lastMousePx = [px, py];
                return;
            }
            const node = hitTestSocket(px, py);
            if (node) {
                dragNode = node;
                lastMousePx = [px, py];
                const s = window._lastDrawState;
                if (s && s.positionsMm && !socketPositions[node]) {
                    socketPositions[node] = s.positionsMm[node].slice();
                }
            }
        }
        
        function canvasMouseMove(e) {
            const [px, py] = getCanvasMouse(e);
            const s = window._lastDrawState;
            if (!s) return;
            const dxPx = px - lastMousePx[0], dyPx = py - lastMousePx[1];
            const dxMm = dxPx * (s.widthMm / s.drawW), dyMm = dyPx * (s.heightMm / s.drawH);
            lastMousePx = [px, py];
            
            if (dragColumn !== null) {
                if (columnX[dragColumn] == null) {
                    const cols = Object.keys(s.columnCenterPx).map(Number).sort((a,b)=>a-b);
                    const idx = cols.indexOf(dragColumn);
                    const xStep = cols.length > 1 ? (s.widthMm - s.widthMm * 0.2) / (cols.length - 1) : 0;
                    columnX[dragColumn] = s.widthMm * 0.1 + idx * xStep;
                }
                columnX[dragColumn] += dxMm;
                const columns = getColumnsFromConnections();
                const nodes = Array.from(columns[dragColumn] || []);
                nodes.forEach(n => {
                    if (socketPositions[n]) socketPositions[n][0] += dxMm;
                    else socketPositions[n] = [s.positionsMm[n][0] + dxMm, s.positionsMm[n][1]];
                });
                drawCanvas();
                return;
            }
            if (dragNode) {
                if (!socketPositions[dragNode]) socketPositions[dragNode] = s.positionsMm[dragNode].slice();
                socketPositions[dragNode][0] += dxMm;
                socketPositions[dragNode][1] += dyMm;
                drawCanvas();
            }
        }
        
        function canvasMouseUp() {
            dragColumn = null;
            dragNode = null;
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            init();
            const canvas = document.getElementById('preview');
            canvas.addEventListener('mousedown', canvasMouseDown);
            canvas.addEventListener('mousemove', canvasMouseMove);
            canvas.addEventListener('mouseup', canvasMouseUp);
            canvas.addEventListener('mouseleave', canvasMouseUp);
        });
        window.addEventListener('resize', drawCanvas);
    </script>
</body>
</html>
