<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sankey Diagram Generator - Web App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 10px 0 0 0;
            margin: 0;
            min-height: 100vh;
        }
        
        .container {
            display: grid;
            grid-template-columns: minmax(280px, 360px) 1fr;
            gap: 10px;
            width: 100%;
            height: 98vh;
            max-width: none;
            margin: 0;
            padding: 0 10px 10px;
        }
        
        .panel {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .left-panel {
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }
        
        h2 {
            font-size: 14px;
            margin: 15px 0 8px 0;
            color: #555;
            font-weight: 600;
        }
        
        .section {
            margin-bottom: 15px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        
        .param-row label {
            flex: 0 0 100px;
            font-size: 13px;
            color: #666;
        }
        
        input[type="number"], input[type="text"] {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button.secondary {
            background: #6c757d;
        }
        
        button.secondary:hover {
            background: #545b62;
        }
        
        button.success {
            background: #28a745;
        }
        
        button.success:hover {
            background: #218838;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .button-grid button {
            width: 100%;
        }
        
        canvas {
            flex: 1;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }
        
        .status {
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 10px;
            color: #495057;
        }
        
        .info-text {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
        }
        
        .value-display {
            font-size: 12px;
            color: #007bff;
            padding: 6px;
            background: #e7f3ff;
            border-radius: 4px;
            margin: 8px 0;
        }
        
        .scale-display {
            font-size: 12px;
            color: #28a745;
            padding: 6px;
            background: #d4edda;
            border-radius: 4px;
            margin: 8px 0;
        }
        
        select {
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            background: white;
        }
        
        .radio-group {
            display: flex;
            gap: 15px;
            margin: 8px 0;
        }
        
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            color: #666;
            cursor: pointer;
        }
        
        input[type="radio"] {
            cursor: pointer;
        }
        
        .column-control {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
            transform: translateX(-50%);
            overflow: visible;
            z-index: 10;
        }
        .column-control input.socket-input {
            min-width: 42px;
            width: 42px;
            padding: 4px 6px;
            font-size: 13px;
            text-align: center;
            box-sizing: border-box;
        }
        .column-control .align-btn {
            padding: 4px 8px;
            font-size: 11px;
            margin-top: 4px;
        }
        #columnInputsOverlay {
            overflow: visible;
        }
        .column-label-box {
            background: rgba(30, 100, 200, 0.95);
            border: 1.5px solid #1a5fb4;
            border-radius: 4px;
            color: #fff;
            font-weight: bold;
            font-size: 13px;
            padding: 4px 10px;
            cursor: crosshair;
            user-select: none;
            white-space: nowrap;
            min-height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 4px;
        }
        .design-viewport {
            flex: 1;
            min-height: 0;
            position: relative;
            overflow: hidden;
            border: 2px dashed #999;
            border-radius: 6px;
            background: #fafafa;
        }
        .design-inner {
            position: absolute;
            left: 50%;
            top: 50%;
            transform-origin: center center;
        }
        .design-inner canvas {
            display: block;
        }
        .design-overlay {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .design-overlay .column-control {
            pointer-events: auto;
        }
        .design-viewport.pan-cursor {
            cursor: grab;
        }
        .design-viewport.pan-cursor:active {
            cursor: grabbing;
        }
        .design-viewport.socket-cursor {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Controls -->
        <div class="panel left-panel">
            <h1>ðŸŽ¨ Sankey Controls</h1>
            
            <div class="section">
                <h2>Columns</h2>
                <div class="param-row">
                    <label>Number of columns:</label>
                    <input type="number" id="numColumns" value="6" min="2" max="20" title="Press Enter to apply">
                </div>
                <div class="info-text">Press Enter to apply</div>
            </div>
            
            <div class="section">
                <h2>Thread Randomization</h2>
                <div class="param-row">
                    <label>Thread ID:</label>
                    <input type="number" id="selectedThread" value="0" min="0">
                    <label style="flex: 0 0 50px;">Seed:</label>
                    <input type="number" id="seedValue" value="42" min="1">
                </div>
                <div class="button-grid">
                    <button onclick="setSeed()">Set Seed</button>
                    <button onclick="randomizeSeed()" class="secondary">Randomize</button>
                </div>
                <div class="info-text">Thread 0 = Col0â†’Col1, Thread 1 = Col1â†’Col2, etc.</div>
            </div>
            
            <div class="section">
                <h2>Physical Dimensions (meters)</h2>
                <div class="param-row">
                    <label>Width (X):</label>
                    <input type="number" id="scaleX" value="1.0" step="0.1" min="0.1">
                    <span style="flex: 0 0 20px;">m</span>
                </div>
                <div class="param-row">
                    <label>Height (Y):</label>
                    <input type="number" id="scaleY" value="1.0" step="0.1" min="0.1">
                    <span style="flex: 0 0 20px;">m</span>
                </div>
                <div class="scale-display" id="scaleDisplay">1.0m Ã— 1.0m (1000mm Ã— 1000mm)</div>
            </div>
            
            <button onclick="updatePreview()" class="success" style="width: 100%; font-size: 15px; padding: 12px; margin: 15px 0;">
                â†» UPDATE PREVIEW
            </button>
            
            <div class="section">
                <h2>Actions</h2>
                <button onclick="autoGenerate()" style="width: 100%; margin-bottom: 8px;">Auto-Generate Random</button>
            </div>
            
            <div class="section">
                <h2>SVG Export Mode</h2>
                <div class="radio-group">
                    <label>
                        <input type="radio" name="svgMode" value="full" checked> Full Curves
                    </label>
                    <label>
                        <input type="radio" name="svgMode" value="segmented"> Segmented
                    </label>
                </div>
            </div>
            
            <div class="section">
                <h2>Import / Export</h2>
                <input type="file" id="csvImport" accept=".csv" style="display: none;" onchange="importCSV(event)">
                <div class="button-grid">
                    <button onclick="document.getElementById('csvImport').click()">Import CSV</button>
                    <button onclick="exportCSV()">Export CSV</button>
                </div>
                <button onclick="saveSVG()" style="width: 100%; margin-top: 8px;">Save SVG</button>
            </div>
            
            <div class="status" id="status">Ready. Click UPDATE PREVIEW to start.</div>
            <div class="status" style="background: #fff3cd; color: #856404; margin-top: 5px;" id="connectionCount">
                Connections: 0
            </div>
        </div>
        
        <!-- Right Panel: Preview -->
        <div class="panel right-panel">
            <div class="preview-header" style="display: flex; align-items: center; gap: 16px; margin-bottom: 8px; flex-shrink: 0;">
                <h1 style="margin-bottom: 0;">Real-time Preview</h1>
                <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: #666;">
                    Zoom:
                    <input type="range" id="zoomSlider" min="25" max="200" value="100" style="width: 220px;">
                    <span id="zoomValue">100%</span>
                </label>
            </div>
            <div class="preview-viewport" style="display: flex; flex: 1; min-height: 0; gap: 8px;">
                <div class="pan-y-slider-wrap" style="display: flex; flex-direction: column; align-items: center; flex-shrink: 0;">
                    <span style="font-size: 10px; color: #666;">Pan Y</span>
                    <div style="height: 100px; display: flex; align-items: center;">
                        <input type="range" id="panYSlider" min="-100" max="100" value="0" style="width: 100px; transform: rotate(-90deg); margin: 0;">
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0;">
                    <div class="design-viewport" id="designViewport">
                        <div class="design-inner" id="designInner">
                            <canvas id="preview"></canvas>
                        </div>
                        <div id="columnInputsOverlay" class="design-overlay"></div>
                    </div>
                    <div class="pan-x-slider-wrap" style="display: flex; align-items: center; gap: 8px; flex-shrink: 0; padding: 4px 0;">
                        <span style="font-size: 10px; color: #666;">Pan X</span>
                        <input type="range" id="panXSlider" min="-100" max="100" value="0" style="flex: 1;">
                    </div>
                </div>
            </div>
            <div class="info-text" style="margin-top: 10px; text-align: center; flex-shrink: 0;">
                Preview shows diagram structure. Drag sockets to adjust; drag column label to move column. SVG export uses exact physical dimensions.
            </div>
        </div>
    </div>

    <script>
        // State
        let connections = [];
        let socketsPerColumn = {};
        let threadSeeds = {};
        let numColumns = 6;
        let columnX = {};           // col -> x_mm (optional; column drag)
        let socketPositions = {};   // node -> [x_mm, y_mm] (optional override; socket drag or import)
        let dragNode = null;
        let dragColumn = null;
        let dragView = false;
        let lastPanMousePx = [0, 0];
        let columnCenterPx = {};    // col -> x pixel (for overlay positioning)
        let previewZoom = 1;
        let panX = 0, panY = 0;
        let designDisplayW = 400, designDisplayH = 300;
        let viewportW = 400, viewportH = 300;
        let maxPanX = 0, maxPanY = 0;
        
        // Initialize
        function init() {
            numColumns = parseInt(document.getElementById('numColumns').value);
            for (let i = 0; i < numColumns; i++) {
                socketsPerColumn[i] = 10;
                if (i < numColumns - 1) {
                    threadSeeds[i] = 42;
                }
            }
            updateScaleDisplay();
            updatePreview();
        }
        
        function updateScaleDisplay() {
            const x = parseFloat(document.getElementById('scaleX').value);
            const y = parseFloat(document.getElementById('scaleY').value);
            const xmm = (x * 1000).toFixed(0);
            const ymm = (y * 1000).toFixed(0);
            document.getElementById('scaleDisplay').textContent = 
                `${x}m Ã— ${y}m (${xmm}mm Ã— ${ymm}mm)`;
        }
        
        // Thread seed control
        function setSeed() {
            const threadId = parseInt(document.getElementById('selectedThread').value);
            const seed = parseInt(document.getElementById('seedValue').value);
            
            if (threadId >= 0 && threadId < numColumns - 1 && seed > 0) {
                threadSeeds[threadId] = seed;
                updatePreview();
                setStatus(`Thread ${threadId} seed set to ${seed}`);
            }
        }
        
        function randomizeSeed() {
            const threadId = parseInt(document.getElementById('selectedThread').value);
            const newSeed = Math.floor(Math.random() * 9999) + 1;
            
            threadSeeds[threadId] = newSeed;
            document.getElementById('seedValue').value = newSeed;
            updatePreview();
            setStatus(`Thread ${threadId} randomized with seed ${newSeed}`);
        }
        
        // Auto-generate
        function autoGenerate() {
            // Randomize all thread seeds
            for (let i = 0; i < numColumns - 1; i++) {
                threadSeeds[i] = Math.floor(Math.random() * 9999) + 1;
            }
            
            // Update displayed seed
            const currentThread = parseInt(document.getElementById('selectedThread').value);
            document.getElementById('seedValue').value = threadSeeds[currentThread] || 42;
            
            updatePreview();
            setStatus('Auto-generated with random seeds');
        }
        
        // Generate connections from parameters.
        // Only column 0 defines the total number of lines; each line is one path from Col0 to last column.
        function generateConnections() {
            connections = [];
            const nLines = socketsPerColumn[0] || 10;
            
            for (let lineId = 0; lineId < nLines; lineId++) {
                const path = [];
                let current = `Col0_Socket${lineId}`;
                
                for (let threadId = 0; threadId < numColumns - 1; threadId++) {
                    const colTo = threadId + 1;
                    const socketsTo = socketsPerColumn[colTo] || 10;
                    const seed = threadSeeds[threadId] || 42;
                    seededRandom(seed + lineId * 1000);
                    
                    const targetIdx = Math.floor(seededRandom() * socketsTo);
                    const target = `Col${colTo}_Socket${targetIdx}`;
                    const value = Math.floor(seededRandom() * 9) + 1;
                    
                    path.push({ source: current, target, value });
                    current = target;
                }
                
                for (const edge of path) {
                    connections.push(edge);
                }
            }
            
            document.getElementById('connectionCount').textContent = `Connections: ${connections.length} (${nLines} lines from Col0)`;
        }
        
        // Seeded random number generator
        let seed = 42;
        function seededRandom(newSeed) {
            if (newSeed !== undefined) {
                seed = newSeed;
            }
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        // Update preview
        function updatePreview() {
            // Update number of columns
            const newNumCols = parseInt(document.getElementById('numColumns').value);
            if (newNumCols !== numColumns) {
                numColumns = newNumCols;
                
                // Initialize new columns/threads
                for (let i = 0; i < numColumns; i++) {
                    if (socketsPerColumn[i] === undefined) {
                        socketsPerColumn[i] = 10;
                    }
                    if (i < numColumns - 1 && threadSeeds[i] === undefined) {
                        threadSeeds[i] = 42;
                    }
                }
                
                // Update UI limits
                document.getElementById('selectedThread').max = Math.max(0, numColumns - 2);
            }
            
            updateScaleDisplay();
            generateConnections();
            reframeDesign();
            setStatus('Preview updated');
        }
        
        function reframeDesign() {
            document.getElementById('zoomSlider').value = 100;
            panX = 0;
            panY = 0;
            var sx = document.getElementById('panXSlider');
            var sy = document.getElementById('panYSlider');
            if (sx) sx.value = 0;
            if (sy) sy.value = 0;
            drawCanvas();
        }
        
        // Draw canvas: only the design viewport content; zoom/pan apply only inside the dashed frame
        function drawCanvas() {
            const canvas = document.getElementById('preview');
            const ctx = canvas.getContext('2d');
            const viewportEl = document.getElementById('designViewport');
            const designInner = document.getElementById('designInner');
            
            if (!viewportEl || !designInner) return;
            
            viewportW = viewportEl.clientWidth;
            viewportH = viewportEl.clientHeight;
            if (viewportW <= 0 || viewportH <= 0) return;
            
            previewZoom = (document.getElementById('zoomSlider')?.value ?? 100) / 100;
            document.getElementById('zoomValue').textContent = Math.round(previewZoom * 100) + '%';
            
            var scaleX = parseFloat(document.getElementById('scaleX').value);
            var scaleY = parseFloat(document.getElementById('scaleY').value);
            var aspectRatio = scaleX / scaleY;
            designDisplayW = Math.min(viewportW, viewportH * aspectRatio);
            designDisplayH = Math.min(viewportH, viewportW / aspectRatio);
            if (designDisplayW < 1) designDisplayW = viewportW;
            if (designDisplayH < 1) designDisplayH = viewportH;
            
            maxPanX = Math.max(0, (designDisplayW * previewZoom - viewportW) / 2);
            maxPanY = Math.max(0, (designDisplayH * previewZoom - viewportH) / 2);
            var panXSlider = document.getElementById('panXSlider');
            var panYSlider = document.getElementById('panYSlider');
            panX = maxPanX > 0 ? (parseFloat(panXSlider?.value || 0) / 100) * maxPanX : 0;
            panY = maxPanY > 0 ? (parseFloat(panYSlider?.value || 0) / 100) * maxPanY : 0;
            panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
            panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
            if (panXSlider) panXSlider.value = maxPanX > 0 ? Math.round((panX / maxPanX) * 100) : 0;
            if (panYSlider) panYSlider.value = maxPanY > 0 ? Math.round((panY / maxPanY) * 100) : 0;
            
            designInner.style.width = designDisplayW + 'px';
            designInner.style.height = designDisplayH + 'px';
            designInner.style.transform = 'translate(-50%, -50%) translate(' + panX + 'px, ' + panY + 'px) scale(' + previewZoom + ')';
            canvas.width = designDisplayW;
            canvas.height = designDisplayH;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (connections.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Click UPDATE PREVIEW to generate diagram', canvas.width / 2, canvas.height / 2);
                window._lastDrawState = null;
                document.getElementById('columnInputsOverlay').innerHTML = '';
                return;
            }
            
            var drawW = designDisplayW;
            var drawH = designDisplayH;
            var offsetX = 0;
            var offsetY = 0;
            
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(offsetX, offsetY, drawW, drawH);
            ctx.setLineDash([]);
            
            const [positionsMm, widthMm, heightMm] = calculatePositionsMm();
            const toPx = (xMm, yMm) => [
                offsetX + (xMm / widthMm) * drawW,
                offsetY + (yMm / heightMm) * drawH
            ];
            const positions = {};
            columnCenterPx = {};
            for (const [node, xy] of Object.entries(positionsMm)) {
                positions[node] = toPx(xy[0], xy[1]);
                const col = parseInt(node.split('_')[0].replace('Col', ''));
                if (columnCenterPx[col] === undefined) columnCenterPx[col] = { sum: positions[node][0], n: 1 };
                else { columnCenterPx[col].sum += positions[node][0]; columnCenterPx[col].n++; }
            }
            Object.keys(columnCenterPx).forEach(col => {
                const o = columnCenterPx[col];
                columnCenterPx[col] = o.sum / o.n;
            });
            
            // Draw connections
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            
            for (const conn of connections) {
                const p1 = positions[conn.source];
                const p2 = positions[conn.target];
                
                if (p1 && p2) {
                    drawBezierCurve(ctx, p1[0], p1[1], p2[0], p2[1]);
                }
            }
            
            // Draw nodes
            ctx.globalAlpha = 1.0;
            for (const [node, [x, y]] of Object.entries(positions)) {
                const colNum = parseInt(node.split('_')[0].replace('Col', ''));
                
                if (colNum === 0) {
                    ctx.fillStyle = '#2ecc71'; // Green
                } else if (colNum === numColumns - 1) {
                    ctx.fillStyle = '#e74c3c'; // Red
                } else {
                    ctx.fillStyle = '#f39c12'; // Orange
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const labelY = offsetY + 20;
            
            // Display aspect ratio and scale info
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Scale: ${scaleX}m Ã— ${scaleY}m (Aspect: ${aspectRatio.toFixed(2)}:1)`, 
                        canvas.width / 2, canvas.height - 10);
            
            window._lastDrawState = { offsetX, offsetY, drawW, drawH, widthMm, heightMm, positions, positionsMm, columnCenterPx: Object.assign({}, columnCenterPx), labelY: offsetY + 20, viewportW, viewportH, designDisplayW, designDisplayH };
            updateColumnOverlay();
        }
        
        function designToViewportX(cx) {
            return viewportW / 2 + panX + (cx - designDisplayW / 2) * previewZoom;
        }
        function designToViewportY(cy) {
            return viewportH / 2 + panY + (cy - designDisplayH / 2) * previewZoom;
        }
        
        function updateColumnOverlay() {
            const overlay = document.getElementById('columnInputsOverlay');
            if (!overlay) return;
            const cols = Object.keys(columnCenterPx).map(Number).sort((a, b) => a - b);
            const labelY = (window._lastDrawState && window._lastDrawState.labelY != null) ? window._lastDrawState.labelY : 20;
            overlay.innerHTML = '';
            cols.forEach(col => {
                const div = document.createElement('div');
                div.className = 'column-control';
                div.style.left = designToViewportX(columnCenterPx[col] || 0) + 'px';
                div.style.top = designToViewportY(labelY) + 'px';
                const labelEl = document.createElement('div');
                labelEl.className = 'column-label-box';
                labelEl.textContent = 'Col ' + col;
                labelEl.dataset.col = col;
                labelEl.addEventListener('mousedown', function(e) {
                    e.preventDefault();
                    dragColumn = parseInt(this.dataset.col);
                    lastMousePx = getCanvasMouse(e);
                });
                const inp = document.createElement('input');
                inp.type = 'number';
                inp.className = 'socket-input';
                inp.min = 1;
                inp.value = socketsPerColumn[col] ?? 10;
                inp.dataset.col = col;
                inp.addEventListener('change', function() {
                    const c = parseInt(this.dataset.col);
                    const v = parseInt(this.value) || 1;
                    socketsPerColumn[c] = v;
                    updatePreview();
                });
                const btn = document.createElement('button');
                btn.className = 'align-btn secondary';
                btn.textContent = 'Align';
                btn.dataset.col = col;
                btn.addEventListener('click', function() { alignColumn(parseInt(this.dataset.col)); });
                div.appendChild(labelEl);
                div.appendChild(inp);
                div.appendChild(btn);
                overlay.appendChild(div);
            });
        }
        
        function alignColumn(col) {
            const columns = getColumnsFromConnections();
            const nodes = Array.from(columns[col] || []);
            nodes.forEach(n => { delete socketPositions[n]; });
            drawCanvas();
            setStatus(`Column ${col} aligned`);
        }
        
        function calculateNodePositions(width, height, offsetX, offsetY) {
            const columns = {};
            
            for (const conn of connections) {
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                
                if (!columns[srcCol]) columns[srcCol] = new Set();
                if (!columns[tgtCol]) columns[tgtCol] = new Set();
                
                columns[srcCol].add(conn.source);
                columns[tgtCol].add(conn.target);
            }
            
            const positions = {};
            const marginX = 60;
            const marginY = 40;
            const usableWidth = width - 2 * marginX;
            const usableHeight = height - 2 * marginY;
            
            const sortedCols = Object.keys(columns).sort((a, b) => a - b);
            const xStep = sortedCols.length > 1 ? usableWidth / (sortedCols.length - 1) : 0;
            
            sortedCols.forEach((col, colIdx) => {
                const nodes = Array.from(columns[col]).sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
                
                const x = offsetX + marginX + (colIdx * xStep);
                const yStep = nodes.length > 1 ? usableHeight / (nodes.length - 1) : 0;
                
                nodes.forEach((node, nodeIdx) => {
                    const y = offsetY + marginY + (nodeIdx * yStep);
                    positions[node] = [x, y];
                });
            });
            
            return positions;
        }
        
        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        
        function drawBezierCurve(ctx, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const cx1 = x1 + dx * 0.5;
            const cy1 = y1;
            const cx2 = x1 + dx * 0.5;
            const cy2 = y2;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);
            ctx.stroke();
        }
        
        // CSV Export with full parameters and socket positions (column#, socket#, X, Y)
        function exportCSV() {
            if (connections.length === 0) {
                alert('No connections to export');
                return;
            }
            const [positionsMm] = calculatePositionsMm();
            
            let csv = '#SANKEY_PARAMETERS\n';
            csv += `num_columns,${numColumns}\n`;
            csv += `scale_x_meters,${document.getElementById('scaleX').value}\n`;
            csv += `scale_y_meters,${document.getElementById('scaleY').value}\n`;
            
            csv += '#SOCKET_CONFIGURATION\n';
            for (let i = 0; i < numColumns; i++) {
                csv += `col_${i}_sockets,${socketsPerColumn[i] || 10}\n`;
            }
            
            csv += '#THREAD_SEEDS\n';
            for (let i = 0; i < numColumns - 1; i++) {
                csv += `thread_${i}_seed,${threadSeeds[i] || 42}\n`;
            }
            
            csv += '#SOCKET_POSITIONS\n';
            csv += 'column,socket,X,Y\n';
            const socketRows = Object.entries(positionsMm).map(([node, xy]) => {
                const col = parseInt(node.split('_')[0].replace('Col', ''));
                const socket = parseInt(node.split('_Socket')[1]);
                return { col, socket, x: xy[0], y: xy[1] };
            });
            socketRows.sort((a, b) => a.col !== b.col ? a.col - b.col : a.socket - b.socket);
            for (const r of socketRows) {
                csv += `${r.col},${r.socket},${r.x},${r.y}\n`;
            }
            
            csv += '#CONNECTIONS\n';
            csv += 'source,target,value\n';
            for (const conn of connections) {
                csv += `${conn.source},${conn.target},${conn.value}\n`;
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sankey_design.csv';
            a.click();
            
            setStatus('Exported complete design to CSV');
        }
        
        // CSV Import with full parameters
        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const lines = text.split('\n');
                
                let mode = 'connections';
                connections = [];
                const tempSockets = {};
                const tempSeeds = {};
                const tempSocketPositions = {};
                let tempNumCols = null;
                let tempScaleX = null;
                let tempScaleY = null;
                
                for (const line of lines) {
                    const parts = line.trim().split(',');
                    if (parts.length === 0 || !parts[0]) continue;
                    
                    if (parts[0].startsWith('#')) {
                        if (parts[0] === '#SANKEY_PARAMETERS') mode = 'parameters';
                        else if (parts[0] === '#SOCKET_CONFIGURATION') mode = 'sockets';
                        else if (parts[0] === '#THREAD_SEEDS') mode = 'seeds';
                        else if (parts[0] === '#SOCKET_POSITIONS') mode = 'socket_positions';
                        else if (parts[0] === '#CONNECTIONS') mode = 'connections';
                        continue;
                    }
                    
                    if (mode === 'parameters') {
                        if (parts[0] === 'num_columns') tempNumCols = parseInt(parts[1]);
                        else if (parts[0] === 'scale_x_meters') tempScaleX = parseFloat(parts[1]);
                        else if (parts[0] === 'scale_y_meters') tempScaleY = parseFloat(parts[1]);
                    } else if (mode === 'sockets') {
                        if (parts[0].startsWith('col_') && parts[0].endsWith('_sockets')) {
                            const colNum = parseInt(parts[0].split('_')[1]);
                            tempSockets[colNum] = parseInt(parts[1]);
                        }
                    } else if (mode === 'seeds') {
                        if (parts[0].startsWith('thread_') && parts[0].endsWith('_seed')) {
                            const threadId = parseInt(parts[0].split('_')[1]);
                            tempSeeds[threadId] = parseInt(parts[1]);
                        }
                    } else if (mode === 'socket_positions') {
                        if (parts[0] === 'column') continue; // Skip header
                        if (parts.length >= 4) {
                            const col = parseInt(parts[0]);
                            const socket = parseInt(parts[1]);
                            const x = parseFloat(parts[2]);
                            const y = parseFloat(parts[3]);
                            const node = `Col${col}_Socket${socket}`;
                            tempSocketPositions[node] = [x, y];
                        }
                    } else if (mode === 'connections') {
                        if (parts[0] === 'source') continue; // Skip header
                        if (parts.length >= 3) {
                            connections.push({
                                source: parts[0].trim(),
                                target: parts[1].trim(),
                                value: parseFloat(parts[2])
                            });
                        }
                    }
                }
                
                // Apply imported parameters
                if (tempNumCols !== null) {
                    numColumns = tempNumCols;
                    document.getElementById('numColumns').value = tempNumCols;
                }
                
                if (tempScaleX !== null) {
                    document.getElementById('scaleX').value = tempScaleX;
                }
                
                if (tempScaleY !== null) {
                    document.getElementById('scaleY').value = tempScaleY;
                }
                
                if (Object.keys(tempSockets).length > 0) {
                    socketsPerColumn = tempSockets;
                }
                
                if (Object.keys(tempSeeds).length > 0) {
                    threadSeeds = tempSeeds;
                    const currentThread = parseInt(document.getElementById('selectedThread').value);
                    if (threadSeeds[currentThread] !== undefined) {
                        document.getElementById('seedValue').value = threadSeeds[currentThread];
                    }
                }
                
                if (Object.keys(tempSocketPositions).length > 0) {
                    socketPositions = tempSocketPositions;
                }
                
                updateScaleDisplay();
                reframeDesign();
                
                document.getElementById('connectionCount').textContent = `Connections: ${connections.length}`;
                setStatus(`Imported complete design: ${connections.length} connections`);
                alert(`Imported complete design:\n- ${connections.length} connections\n- ${numColumns} columns\n- All parameters restored`);
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }
        
        // SVG Export
        function saveSVG() {
            if (connections.length === 0) {
                alert('Generate connections first');
                return;
            }
            
            const mode = document.querySelector('input[name="svgMode"]:checked').value;
            
            if (mode === 'full') {
                generateFullCurveSVG();
            } else {
                generateSegmentedCurveSVG();
            }
        }
        
        function generateFullCurveSVG() {
            // Build graph
            const graph = {};
            const nodeType = {};
            
            for (const conn of connections) {
                if (!graph[conn.source]) graph[conn.source] = [];
                graph[conn.source].push([conn.target, conn.value]);
                
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                
                nodeType[conn.source] = srcCol === 0 ? 'input' : (srcCol === numColumns - 1 ? 'output' : 'joint');
                nodeType[conn.target] = tgtCol === 0 ? 'input' : (tgtCol === numColumns - 1 ? 'output' : 'joint');
            }
            
            // Get all Column 0 sockets (inputs) - sorted for consistency
            const inputNodes = Object.keys(nodeType)
                .filter(n => nodeType[n] === 'input')
                .sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
            
            // Trace exactly ONE path per input socket
            const allPaths = [];
            
            function traceSinglePath(current, path, visited) {
                // Trace one path from input to output - take first available connection
                if (nodeType[current] === 'output') {
                    return true; // Found an output, path is complete
                }
                
                if (visited.has(current)) {
                    return false; // Circular reference, abort
                }
                
                visited.add(current);
                
                // Get connections from current node
                const connections = graph[current] || [];
                if (connections.length === 0) {
                    return false; // Dead end
                }
                
                // Take the FIRST connection (deterministic - ensures one path per input)
                for (const [next, value] of connections) {
                    path.push([current, next, value]);
                    if (traceSinglePath(next, path, visited)) {
                        return true; // Successfully reached output
                    }
                    path.pop(); // Backtrack if this path didn't work
                }
                
                return false; // No valid path found
            }
            
            // Trace exactly one path for each input socket
            for (const inputNode of inputNodes) {
                const path = [];
                const visited = new Set();
                if (traceSinglePath(inputNode, path, visited)) {
                    allPaths.push(path);
                }
                // If no valid path exists for this input, it's simply skipped
            }
            
            // Calculate positions
            const [positions, widthMm, heightMm] = calculateSVGNodePositions();
            
            // Generate SVG
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<!-- Physical dimensions: ${document.getElementById('scaleX').value}m Ã— ${document.getElementById('scaleY').value}m -->\n`;
            svg += `<!-- Units: millimeters (1 SVG unit = 1mm) -->\n`;
            svg += `<!-- Full Curves Mode: ${allPaths.length} curves (one per Column 0 socket) -->\n`;
            svg += `<svg width="${widthMm}mm" height="${heightMm}mm" viewBox="0 0 ${widthMm} ${heightMm}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<g id="sankey_threads">\n`;
            
            let threadCount = 0;
            for (const path of allPaths) {
                if (path.length === 0) continue;
                
                const nodes = [path[0][0]];
                for (const [src, tgt, val] of path) {
                    nodes.push(tgt);
                }
                
                const points = nodes.map(n => positions[n]).filter(p => p !== undefined);
                if (points.length < 2) continue;
                
                const pathD = createSmoothCurvePath(points);
                const color = getThreadColor(threadCount, allPaths.length);
                
                svg += `  <path id="thread_${threadCount}" class="full_thread from_${nodes[0]}" d="${pathD}" stroke="${color}" stroke-width="2" fill="none" opacity="0.7"/>\n`;
                threadCount++;
            }
            
            svg += `</g>\n</svg>`;
            
            downloadFile('sankey_full.svg', svg, 'image/svg+xml');
            setStatus(`Saved ${threadCount} full curves as SVG (one per Column 0 socket)`);
        }
        
        function generateSegmentedCurveSVG() {
            const [positions, widthMm, heightMm] = calculateSVGNodePositions();
            const nextNode = {};
            for (const conn of connections) {
                nextNode[conn.source] = conn.target;
            }
            const nLines = socketsPerColumn[0] || 10;
            const allPaths = [];
            for (let i = 0; i < nLines; i++) {
                const path = [];
                let cur = `Col0_Socket${i}`;
                while (cur && positions[cur]) {
                    path.push(cur);
                    cur = nextNode[cur];
                }
                if (path.length >= 2) allPaths.push(path);
            }
            let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            svg += `<!-- Physical dimensions: ${document.getElementById('scaleX').value}m Ã— ${document.getElementById('scaleY').value}m -->\n`;
            svg += `<!-- Units: millimeters (1 SVG unit = 1mm) -->\n`;
            svg += `<!-- Segmented: full curves split at sockets -->\n`;
            svg += `<svg width="${widthMm}mm" height="${heightMm}mm" viewBox="0 0 ${widthMm} ${heightMm}" xmlns="http://www.w3.org/2000/svg">\n`;
            svg += `<g id="sankey_segments">\n`;
            let segmentCount = 0;
            for (let pi = 0; pi < allPaths.length; pi++) {
                const path = allPaths[pi];
                const points = path.map(n => positions[n]).filter(p => p);
                for (let i = 0; i < points.length - 1; i++) {
                    const pathD = createSmoothCurvePath([points[i], points[i + 1]]);
                    const color = getThreadColor(pi, allPaths.length);
                    svg += `  <path id="segment_${segmentCount}" d="${pathD}" stroke="${color}" stroke-width="2" fill="none" opacity="0.7"/>\n`;
                    segmentCount++;
                }
            }
            svg += `</g>\n</svg>`;
            downloadFile('sankey_segmented.svg', svg, 'image/svg+xml');
            setStatus(`Saved ${segmentCount} segments (full curves split at sockets)`);
        }
        
        function getColumnsFromConnections() {
            const columns = {};
            for (const conn of connections) {
                const srcCol = parseInt(conn.source.split('_')[0].replace('Col', ''));
                const tgtCol = parseInt(conn.target.split('_')[0].replace('Col', ''));
                if (!columns[srcCol]) columns[srcCol] = new Set();
                if (!columns[tgtCol]) columns[tgtCol] = new Set();
                columns[srcCol].add(conn.source);
                columns[tgtCol].add(conn.target);
            }
            return columns;
        }
        
        function calculatePositionsMm() {
            const scaleX = parseFloat(document.getElementById('scaleX').value);
            const scaleY = parseFloat(document.getElementById('scaleY').value);
            const widthMm = scaleX * 1000;
            const heightMm = scaleY * 1000;
            const marginX = widthMm * 0.1;
            const marginY = heightMm * 0.1;
            const columns = getColumnsFromConnections();
            const sortedCols = Object.keys(columns).sort((a, b) => a - b);
            const xStep = sortedCols.length > 1 ? (widthMm - 2 * marginX) / (sortedCols.length - 1) : 0;
            const positions = {};
            sortedCols.forEach((col, colIdx) => {
                const nodes = Array.from(columns[col]).sort((a, b) => {
                    const aSocket = parseInt(a.split('_Socket')[1]);
                    const bSocket = parseInt(b.split('_Socket')[1]);
                    return aSocket - bSocket;
                });
                const baseX = columnX[col] != null ? columnX[col] : (marginX + colIdx * xStep);
                const yStep = nodes.length > 1 ? (heightMm - 2 * marginY) / (nodes.length - 1) : 0;
                nodes.forEach((node, nodeIdx) => {
                    const y = marginY + (nodeIdx * yStep);
                    if (socketPositions[node]) {
                        positions[node] = socketPositions[node].slice();
                    } else {
                        positions[node] = [baseX, y];
                    }
                });
            });
            return [positions, widthMm, heightMm];
        }
        
        function calculateSVGNodePositions() {
            return calculatePositionsMm();
        }
        
        function createSmoothCurvePath(points) {
            if (points.length < 2) return '';
            
            let path = `M ${points[0][0]},${points[0][1]}`;
            
            for (let i = 0; i < points.length - 1; i++) {
                const [x1, y1] = points[i];
                const [x2, y2] = points[i + 1];
                const dx = x2 - x1;
                const cx1 = x1 + dx * 0.5;
                const cy1 = y1;
                const cx2 = x1 + dx * 0.5;
                const cy2 = y2;
                
                path += ` C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
            }
            
            return path;
        }
        
        function getThreadColor(index, total) {
            const hue = (index * 360 / total) % 360;
            return `hsl(${hue}, 70%, 50%)`;
        }
        
        function downloadFile(filename, content, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
        }
        
        function setStatus(msg) {
            document.getElementById('status').textContent = msg;
        }
        
        // Event listeners
        document.getElementById('numColumns').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                updatePreview();
            }
        });
        document.getElementById('scaleX').addEventListener('input', function() {
            updateScaleDisplay();
            if (connections.length > 0) reframeDesign();
        });
        document.getElementById('scaleY').addEventListener('input', function() {
            updateScaleDisplay();
            if (connections.length > 0) reframeDesign();
        });
        document.getElementById('selectedThread').addEventListener('input', function() {
            const threadId = parseInt(this.value);
            if (threadSeeds[threadId] !== undefined) {
                document.getElementById('seedValue').value = threadSeeds[threadId];
            }
        });
        document.getElementById('zoomSlider').addEventListener('input', function() {
            previewZoom = parseInt(this.value) / 100;
            document.getElementById('zoomValue').textContent = this.value + '%';
            drawCanvas();
        });
        document.getElementById('panXSlider').addEventListener('input', function() {
            drawCanvas();
        });
        document.getElementById('panYSlider').addEventListener('input', function() {
            drawCanvas();
        });
        
        let lastMousePx = [0, 0];
        
        function getCanvasMouse(e) {
            const canvas = document.getElementById('preview');
            const r = canvas.getBoundingClientRect();
            const scaleX = canvas.width / r.width;
            const scaleY = canvas.height / r.height;
            return [(e.clientX - r.left) * scaleX, (e.clientY - r.top) * scaleY];
        }
        
        function hitTestColumnLabel(px, py) {
            const s = window._lastDrawState;
            if (!s || !s.columnCenterPx) return null;
            const cols = Object.keys(s.columnCenterPx).map(Number);
            for (const col of cols) {
                const lx = s.columnCenterPx[col];
                const ly = s.labelY;
                if (Math.abs(px - lx) < 45 && Math.abs(py - ly) < 14) return col;
            }
            return null;
        }
        
        function hitTestSocket(px, py) {
            const s = window._lastDrawState;
            if (!s || !s.positions) return null;
            const r = 10;
            let best = null, bestD = r * r;
            for (const [node, [x, y]] of Object.entries(s.positions)) {
                const d = (px - x) ** 2 + (py - y) ** 2;
                if (d < bestD) { bestD = d; best = node; }
            }
            return best;
        }
        
        function canvasMouseDown(e) {
            const [px, py] = getCanvasMouse(e);
            const col = hitTestColumnLabel(px, py);
            if (col != null) {
                dragColumn = col;
                lastMousePx = [px, py];
                return;
            }
            const node = hitTestSocket(px, py);
            if (node) {
                dragNode = node;
                lastMousePx = [px, py];
                const s = window._lastDrawState;
                if (s && s.positionsMm && !socketPositions[node]) {
                    socketPositions[node] = s.positionsMm[node].slice();
                }
                return;
            }
            dragView = true;
            lastPanMousePx = [e.clientX, e.clientY];
            document.addEventListener('mousemove', docPanMove);
            document.addEventListener('mouseup', docPanUp);
        }
        
        function docPanMove(e) {
            if (!dragView) return;
            var dx = e.clientX - lastPanMousePx[0];
            var dy = e.clientY - lastPanMousePx[1];
            lastPanMousePx = [e.clientX, e.clientY];
            panX = Math.max(-maxPanX, Math.min(maxPanX, panX + dx));
            panY = Math.max(-maxPanY, Math.min(maxPanY, panY + dy));
            var sx = document.getElementById('panXSlider');
            var sy = document.getElementById('panYSlider');
            if (sx) sx.value = maxPanX > 0 ? Math.round((panX / maxPanX) * 100) : 0;
            if (sy) sy.value = maxPanY > 0 ? Math.round((panY / maxPanY) * 100) : 0;
            drawCanvas();
        }
        
        function docPanUp() {
            dragView = false;
            document.removeEventListener('mousemove', docPanMove);
            document.removeEventListener('mouseup', docPanUp);
        }
        
        function updateCanvasCursor(px, py) {
            const viewportEl = document.getElementById('designViewport');
            if (!viewportEl) return;
            const node = hitTestSocket(px, py);
            const col = hitTestColumnLabel(px, py);
            viewportEl.classList.remove('pan-cursor', 'socket-cursor');
            if (node || col != null) {
                viewportEl.classList.add('socket-cursor');
            } else {
                viewportEl.classList.add('pan-cursor');
            }
        }
        
        function canvasMouseMove(e) {
            const [px, py] = getCanvasMouse(e);
            const s = window._lastDrawState;
            
            if (dragView) return;
            
            if (connections.length > 0 && s) {
                updateCanvasCursor(px, py);
            }
            
            if (!s) return;
            const dxPx = px - lastMousePx[0], dyPx = py - lastMousePx[1];
            const dxMm = dxPx * (s.widthMm / s.drawW), dyMm = dyPx * (s.heightMm / s.drawH);
            lastMousePx = [px, py];
            
            if (dragColumn !== null) {
                if (columnX[dragColumn] == null) {
                    const cols = Object.keys(s.columnCenterPx).map(Number).sort((a,b)=>a-b);
                    const idx = cols.indexOf(dragColumn);
                    const xStep = cols.length > 1 ? (s.widthMm - s.widthMm * 0.2) / (cols.length - 1) : 0;
                    columnX[dragColumn] = s.widthMm * 0.1 + idx * xStep;
                }
                columnX[dragColumn] += dxMm;
                const columns = getColumnsFromConnections();
                const nodes = Array.from(columns[dragColumn] || []);
                nodes.forEach(n => {
                    if (socketPositions[n]) socketPositions[n][0] += dxMm;
                    else socketPositions[n] = [s.positionsMm[n][0] + dxMm, s.positionsMm[n][1]];
                });
                drawCanvas();
                return;
            }
            if (dragNode) {
                if (!socketPositions[dragNode]) socketPositions[dragNode] = s.positionsMm[dragNode].slice();
                socketPositions[dragNode][0] += dxMm;
                socketPositions[dragNode][1] += dyMm;
                drawCanvas();
            }
        }
        
        function canvasMouseUp() {
            if (dragView) {
                docPanUp();
            } else {
                dragColumn = null;
                dragNode = null;
            }
            var viewportEl = document.getElementById('designViewport');
            if (viewportEl) viewportEl.classList.remove('pan-cursor', 'socket-cursor');
        }
        
        function canvasMouseLeave() {
            var viewportEl = document.getElementById('designViewport');
            if (viewportEl) viewportEl.classList.remove('pan-cursor', 'socket-cursor');
        }
        
        // Initialize on load
        window.addEventListener('load', function() {
            init();
            const canvas = document.getElementById('preview');
            canvas.addEventListener('mousedown', canvasMouseDown);
            canvas.addEventListener('mousemove', canvasMouseMove);
            canvas.addEventListener('mouseup', canvasMouseUp);
            canvas.addEventListener('mouseleave', function() {
                canvasMouseUp();
                canvasMouseLeave();
            });
        });
        window.addEventListener('resize', drawCanvas);
    </script>
</body>
</html>
